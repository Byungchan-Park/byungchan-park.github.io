---
title: "CORS란?"
excerpt: "CORS의 3가지 시나리오"

categories:
  - TIL
tags:
  - TIL
  - CORS
last_modified_at: 2020-09-19T08:06:00-05:00
---

# CORS(Cross Origin Resource Sharing)

출처가 다른 두 개의 어플리케이션이 마음대로 소통할 수 있는 환경은 꽤 위험환 환경이므로,
브라우저는 몇 가지 예외사항에 해당하는 리소스 요청은 출처가 다르더라도 허용하기로 했는데,
그것이 "CORS 정책을 지킨 리소스 요청"이다.
우리가 다른 출처로 리소스를 요청할 때 이 CORS 정책을 지키지 않는다면 브라우저가 아예 다른 출처의 리소스를 허용하지 않을 것이다.

### 그렇다면 같은 출처와 다른 출처는 어떻게 구분되는 걸까?

URL의 구성 요소 중 Scheme, Host, Port 이 3가지만 동일하면 된다.
https://byungchan-park.github.io:80 라는 출처를 예로 들면
https:// 이라는 스킴에
byungchan-park.github.io 호스트를 가지고
80번 포트를 사용하고 있다는 것만 같다면
나머지는 전부 다르더라도 같은 출처로 인정이 된다.

출처를 비교하는 로직은 서버에 구현된 스펙이 아니라 브라우저에 구현되어 있는 스펙이다.
만약 우리가 CORS 정책을 위반하는 리소스 요청을 하더라도 서버는 정상적으로 응답을 한다.
이후 브라우저가 이 응답을 분석해서 CORS 정책 위반이라고 판단되면
그 응답을 사용하지 않고 그냥 버린다.

즉, 서버는 CORS를 위반하더라도 정상적으로 응답을 해주고, 응답의 파기 여부는 브라우저가 결정한다.

CORS 정책을 위반하는 리소스 요청 때문에 에러가 발생했다고 해도
서버 쪽 로그에는 정상적으로 응답을 했다는 로그만 남기 때문에,
CORS가 돌아가는 방식을 정확히 모르면 에러 트레이싱에 난항을 겪을 수도 있다.

## CORS는 어떻게 동작할까?

기본적으로 웹 클라이언트 어플리케이션이 다른 출처의 리소스를 요청할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되는데, 이때 브라우저는 요청 헤더에 Origin이라는 필드에 요청을 보내는 출처를 함께 담아보낸다.
이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 Access-Control-Allow-Origin 이라는 값에 "이 리소스를 접근하는 것이 허용된 출처"를 내려주고, 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.

기본적인 흐름은 이와 같고, 사실 CORS가 동작하는 방식은 세 가지 시나리오에 따라 변경된다.

### Preflight Request

Preflight Request에 해당하는 상황일 때 브라우저는 요청을 한번에 보내지 않고 예비 요청과 본 요청으로 나누어서 서버로 전송한다.
이때 브라우저가 본 요청을 보내기 전에 보내는 예비 요청을 Preflight라고 부르는 것이며, 이 예비 요청에는 HTTP 메소드 중 OPTIONS 메소드가 사용된다. 예비 요청의 역할은 본 요청을 보내기 전에 브라우저 스스로 이 요청을 보내는 것이 안전한지 확인하는 것이다.
브라우저는 본 요청을 보내기 전 예비 요청을 먼저 보내고, 요청의 유효성을 검사한다.
주의할 것!!!
CORS 정책 위반으로 인한 에러는 예비 요청의 성공 여부와 별 상관이 없다.
브라우저가 CORS 정책 위반 여부를 판단하는 시점은 예비 요청에 대한 응답을 받은 이후이다.
물론 예비 요청 자체가 실패해도 똑같이 CORS 정책 위반으로 처리될 수도 있지만, 중요한 것은 예비 요청의 성공/실패 여부가 아니라 “응답 헤더에 유효한 Access-Control-Allow-Origin 값이 존재하는가”이다.

### Simple Request

Simple Request는 예비 요청을 보내지 않고 바로 서버에게 본 요청부터 때려박은 후,
서버가 이에 대한 응답의 헤더에 Access-Control-Allow-Origin과 같은 값을 보내주면
그때 브라우저가 CORS 정책 위반 여부를 검사하는 방식이다.
즉, 프리플라이트와 단순 요청 시나리오는 전반적인 로직 자체는 같되, 예비 요청의 존재 유무만 다르다.

특정 조건을 만족하는 경우에만 예비 요청을 생략할 수 있다.
이 조건이 조금 까다롭기 때문에
일반적인 방법으로 웹 어플리케이션 아키텍처를 설계하게 되면
거의 충족시키기 어려운 조건들이다.

1. 요청의 메소드는 GET, HEAD, POST 중 하나여야 한다.
2. Accept, Accept-Language, Content-Language, Content-Type, DPR, Downlink, Save-Data, Viewport-Width, Width를 제외한 헤더를 사용하면 안된다.
3. 만약 Content-Type를 사용한 경우에는 application/x-www-form-urlencoded, multipart/form-data, text/plain 만 허용된다.

대부분의 HTTP API는 text/xml이나 application/json 컨텐츠 타입을 가지도록 설계되기 때문에 사실상 이 조건들을 모두 만족시키는 상황은 만들기는 그렇게 쉽지 않은 것이 현실이다.

### Credentialed Request

이 시나리오는 CORS의 기본적인 방식이라기 보다는 다른 출처 간 통신에서 좀 더 보안을 강화하고 싶을 때 사용하는 방법이다.
기본적으로 브라우저가 제공하는 비동기 리소스 요청 API인 XMLHttpRequest 객체나 fetch API는 별도의 옵션 없이 브라우저의 쿠키 정보나 인증과 관련된 헤더를 함부로 요청에 담지 않는다. 이때 요청에 인증과 관련된 정보를 담을 수 있게 해주는 옵션이 바로 credentials 옵션이다.

이 옵션에는 총 3가지의 값을 사용할 수 있으며, 각 값들이 가지는 의미는 다음과 같다.

- same-origin(기본값) : 같은 출처 간 요청에만 인증 정보를 담을 수 있다.
- include: 모든 요청에 인증 정보를 담을 수 있다.
- omit: 모든 요청에 인증 정보를 담지 않는다.

만약 same-origin이나 include와 같은 옵션을 사용하여 리소스 요청에 인증 정보가 포함된다면,
이제 브라우저는 다른 출처의 리소스를 요청할 때 단순히 Access-Control-Allow-Origin만 확인하는 것이 아니라
좀 더 빡빡한 검사 조건을 추가하게 된다.

브라우저는 인증 모드가 'include'일 경우, 모든 요청을 허용한다는 의미의 '\*'를 'Access-Control-Allow-Origin' 헤더에 사용하면 안된다고 이야기한다.

이처럼 요청에 인증 정보가 담겨있는 상태에서 다른 출처의 리소스를 요청하게 되면 브라우저는 CORS 정책 위반 여부를 검사하는 룰에 다음 두 가지를 추가하게 된다.

1. 'Access-Control-Allow-Origin'에는 '\*'를 사용할 수 없으며, 명시적인 URL이어야한다.
2. 응답 헤더에는 반드시 'Allow-Control-Allow-Credentials: true'가 존재해야 한다.
